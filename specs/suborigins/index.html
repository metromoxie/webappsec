<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Suborigins</title>
  <script src='https://www.w3.org/Tools/respec/respec-w3c-common' class='remove'></script>
  <script class='remove'>
    var respecConfig = {
        // specification status (e.g. WD, LCWD, NOTE, etc.). If in doubt use ED.
        // Member-SUBM
        specStatus:           "ED",

        // the specification's short name, as in http://www.w3.org/TR/short-name/
        shortName:            "suborigins",

        // if the specification's copyright date is a range of years, specify
        // the start date here:
        copyrightStart:       "2014",

        // if there a publicly available Editor's Draft, this is the link
        edDraftURI:           "http://w3c.github.io/webappsec/specs/suborigins/",

        // editors, add as many as you like
        // only "name" is required
        editors:  [
            { name: "Joel Weinberger", url: "mailto:jww@google.com", company: "Google, Inc.", companyURL: "https://google.com/" },
        ],

        // name of the WG
        wg:           "Web Application Security Working Group",

        // URI of the public WG page
        wgURI:        "http://www.w3.org/2011/webappsec/",

        // name (with the @w3c.org) of the public mailing to which comments are due
        wgPublicList: "public-webappsec",
        subjectPrefix: "[Suborigins]",

        // URI of the patent status for this WG, for Rec-track documents
        // !!!! IMPORTANT !!!!
        // This is important for Rec-track documents, do not copy a patent URI from a random
        // document unless you know what you're doing. If in doubt ask your friendly neighbourhood
        // Team Contact.
        wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/49309/status",

        localBiblio: {
          "CSP": {
            title: "Content Security Policy 1.1",
            href: "http://w3.org/TR/CSP11",
            authors: [
              "Adam Barth",
              "Dan Veditz",
              "Mike West"
            ],
            status: "Working Draft",
            publisher: "W3C"
          },
          "PrivilegeSeparation": {
            title: "Privilege Separation in HTML5 Applications",
            href: "https://www.usenix.org/system/files/conference/usenixsecurity12/sec12-final168.pdf",
            authors: [
              "Devdatta Akhawe",
              "Prateek Saxena",
              "Dawn Song"
            ],
            publisher: "USENIX"
          },
        }
    };
  </script>
</head>
<body>
<section id="abstract">
  <p>This specification defines a mechanism by which a server may specify a web
resource response a new origin in the user agent which is a combination of the
server’s origin and a specified namespace.</p>
</section>

<section id="sotd">
  <p>A list of changes to this document may be found at
<a href="https://github.com/w3c/webappsec">https://github.com/w3c/webappsec</a>.</p>
</section>

<section class="informative">
  <h3 id="introduction">Introduction</h3>

  <p>Currently, web applications are almost always compartmentalized by using
separate host names to establish separate web origins. This is useful for
helping to prevent XSS and other cross-origin attacks, but has many unintended
consequences. For example, it causes latency due to additional DNS lookups,
removes the ability to use single-origin features (such as the
history.pushState API), and creates cryptic host name changes in the user
experience. Perhaps most importantly, it results in an extremely inflexible
architecture that, once rolled out, cannot be easily and transparently changed
later on.</p>

  <p>There are several mechanisms for reducing the attack surface for XSS without
creating separate host-name based origins, but each pose their own problems.
Per-page Suborigins is an attempt to fill some of those gaps. Two of the most
notable mechanisms are Sandboxed Frames and Content Security Policy (CSP). Both
are powerful but have shortcomings and there are many external developers
building legacy applications that find they cannot use those tools.</p>

  <p>Sandboxed frames can be used to completely separate untrusted content, but they
pose a large problem for containing trusted but potentially buggy code because
it is very difficult, by design, for them to communicate with other frames. The
synthetic origins assigned in a sandboxed frame are random and unpredictable,
making the use of postMessage and CORS difficult. Moreover, because they are by
definition unique origins, with no relationship to the original origin,
designing permissions for them to access resources of the original origin would
be difficult.</p>

  <p>Content Security Policy is also promising but is generally incompatible with
current website design. Many notable companies found it impractical to retrofit
most of their applications with it. On top of this, until all applications
hosted within a single origin are simultaneously put behind CSP, the mechanism
offers limited incremental benefits, which is especially problematic for
companies with large portfolios of disparate products all under the same domain.</p>

  <section>
    <h3 id="goals">Goals</h3>

    <ol>
      <li>
        <p>Provide a way for different applications hosted at the same real origin to
separate their content into separate logical origins. For example,
https://foobar.com/application and https://foobar.com/widget, today, are, by
definition, in the same origin, even if they’re different applications. Thus an
XSS at https://foobar.com/application means an XSS at
https://foobar.com/widget, even if https://foobar.com/widget is “protected” by
a strong Content Security Policy.</p>
      </li>
      <li>
        <p>Similarly, provide a way for content authors to split their applications
into logical modules with origin level separation without using different real
origins. Content authors should not have to choose between putting all of their
content in the same origin, on different real origins, or putting content in
anonymous unique origins (sandboxes).</p>
      </li>
      <li>
        <p>Provide a way for content authors to attribute different permissions such as
cookie access, storage access, etc. to different suborigins.</p>
      </li>
    </ol>

    <p class="issue">Not sure how to actually refer to ‘real origins’. This is a terrible name, and
we need a better way to talk about them. Maybe physical origin? Traditional
origin? (jww)</p>
  </section>
  <!-- /Introduction::Goals -->

  <section>
    <h3 id="use-casesexamples">Use Cases/Examples</h3>

    <p>We see effectively three different use cases for Per-page Suborigins:</p>

    <ol>
      <li>
        <p>Separating distinct applications that happen to be served from the same
domain, but do not need to extensively interact with other content. Examples
include marketing campaigns, simple search UIs, and so on. This use requires
very little engineering effort and faces very few constraints; the applications
may use XMLHttpRequest and postMessage to communicate with their host domain as
required.</p>
      </li>
      <li>
        <p>Allowing for modularity within a larger web application by splitting the
functional components into different suborigins. For example, Gmail might put
the contacts widget, settings tab, and HTML message views in separate Per-page
Suborigins. Such deployments may require relatively modest refactorings to
switch to postMessage and CORS where direct DOM access and same-origin
XMLHttpRequest are currently used, but we believe doing so is considerably
easier than retrofitting CSP onto arbitrary code bases and can be done very
incrementally.</p>
      </li>
      <li>
        <p>Similar to (2), applications with many users can split information relating
to different users into their own suborigin. For example, Twitter might put
each user profile into a unique suborigin so that an XSS within one profile
cannot be used to immediately infect other users or read their personal
messages stored within the account.</p>
      </li>
    </ol>

  </section>
  <!-- /Introduction::Use Cases/Examples -->
</section>
<!-- /Introduction -->

<section id="conformance">

  <p>Conformance requirements phrased as algorithms or specific steps can be
implemented in any manner, so long as the end result is equivalent. In
particular, the algorithms defined in this specification are intended to
be easy to understand and are not intended to be performant. Implementers
are encouraged to optimize.</p>

  <section>
    <h3 id="key-concepts-and-terminology">Key Concepts and Terminology</h3>

    <p>This section defines several terms used throughout the document.</p>

    <p>The term <dfn>origin</dfn> is defined in the Origin specification.
[[!RFC6454]]</p>

  </section>
  <p><!-- /Conformance::Key Concepts and Terminology --></p>
</section>
<p><!-- /Conformance --></p>

<section>
  <h3 id="framework">Framework</h3>

  <section>
    <h3 id="defining-a-suborigin">Defining a Suborigin</h3>

    <p>Origins are a mechanism for user agents to group URIs into protection domains.
Two URIs are in the same origin if they share the same scheme, host, and port.
If URIs are in the same origin, then they share the same authority and can
access all of each others resources.</p>

    <p>This has been a successful mechanism for privilege separation on the Web.
However, it does limit the ability of a URI to separate itself into a new
protection domain as it automatically shares authority with all other identical
origins, which are defined by physical, rather than programatic, properties.
While it is possible to setup unique domains and ports different parts of the
same application (scheme is more difficult to separate out), there are a diverse
set of practical problems in doing so.</p>

    <p>Suborigins provide a mechanism for creating this type of separation
programatically. Any resources may provide, in a manner detailed below, a string
value <dfn>suborigin namespace</dfn>.  If either of two URIs provide a suborigin
namespace, then the two URIs are in the same origin if and only if they share
the same scheme, host, port, and suborigin namespace.</p>

    <p>Q. In today’s Web, can’t a site get the effective same protection domain simply
by hosting their content at different subdomains?</p>

    <p>A. Yes, but there are many practical reasons why this is difficult.</p>

    <section>
      <h3 id="examples">Examples</h3>

      <h4 id="separate-applications-same-origin">Separate applications, same origin</h4>
      <p>Google runs Search and Maps on the same domain, respectively
<code>https://www.google.com</code> and <code>https://www.google.com/maps</code>. While these two
applications are fundamentally separate, there are many reasons for hosting them
on the same origin, including historical links, branding, and performance.
However, from security perspective, this means that a compromise of one
application is a compromise of the other since the only security boundary in the
browser is the origin, and both applications are hosted on the same origin.
Thus, even if Google Search were to successful implement a strong Content
Security Policy [[CSP]], if Google Maps were to have an XSS vulnerability, it
would be equivalent to having an XSS on Google Search as well, negating Google
Search’s security measures.</p>

      <h4 id="separation-within-a-single-application">Separation within a single application</h4>
      <p>Separation is sometimes desirable within a single application because of the
presence of untrusted data. Take, for example, a social networking site with
many different user profiles. Each profile contains lots of untrusted content
created by a single user but it’s all hosted on a single origin. In order to
separate untrusted content, the application might want a way to put all profile
information into separate logical origins while all being hosted at the same
physical origin. Furthermore, all content within a profile should be able to
access all other content within the same origin, even if displayed in unique
frames.</p>

      <p>This type of privilege separation within an application has been shown to be
valuable and reasonable for applications to do by work such as
Privilege Separation in HTML5 Applications by Akhawe et al
[[PrivilegeSeparation]]. However, these systems rely on cross frame messaging
using <code>postMessage</code> even for content in the same trust boundary since they
utilize <code>sandbox</code>. This provides much of the motivation for the named container
nature of suborigins.</p>

    </section>
    <p><!-- /Framework::Defining a Suborigin::Examples --></p>

    <section>
      <h3 id="relationship-of-suborigins-to-origins">Relationship of Suborigins to Origins</h3>

      <p>Suborigins, in fact, do not provide any new authority to resources. Suborigins
simply provide <em>an additional way to construct Origins</em>. That is,
Suborigins do not supercede Origins or provide any additional authority above
Origins. From the user agent’s  perspective, two resources in different
Suborigins are simply in different Origins, and the relationship between the two
resources should be the same as any other two differing origins as described in
[[!RFC6454]].  Thus, this specification is intended to provide the following two
important properties:</p>

      <ul>
        <li>The rules on how Suborigins are defined.</li>
        <li>The rules on how Suborigins are tracked.</li>
      </ul>

    </section>
    <p><!-- /Framework::Defining a Suborigin::Relationship of Suborigins to Origins--></p>

    <section>
      <h3 id="serialization">Serialization</h3>

      <p>At an abstract level, a suborigin consists of a scheme, host, and port of a
traditional origin, plus a <a href="#dfn-suborigin-namespace">suborigin namespace</a>. However, as mentioned above,
suborigins are intended to fit within the framework of [[!RFC6454]]. Therefore,
this specification provides a way of serializing a Suborigin bound resource into
a traditional Origin. This is done by inserting the suborigin namespace into the
scheme space of the Origin, thus creating a new scheme but maintaining all of
the information about both the original scheme and the suborigin namespace. This
is done by inserting a <code>+</code> into the URI after the scheme, followed by the
suborigin namespace, then followed by the rest of the URI starting with <code>:</code>.</p>

      <p>For example, if the resource is hosted at <code>https://example.com/</code> in the
suborigin namespace <code>profile</code>, this would be serialized as
<code>https+profile://example.com/</code>.</p>

      <p>Similarly, if a resource is hosted at <code>https://example.com:8080/</code> in the
suborigin namespace <code>separate</code>, this would be serialized as
<code>https+separate://example.com:8080/</code>.</p>
    </section>
    <p><!-- /Framework::Defining a Suborigin::Serialization --></p>

    <section>
      <h3 id="opting-into-a-suborigin">Opting into a Suborigin</h3>

      <p>Unlike the <code>sandbox</code> attribute, suborigin namespaces are predictable and
controllable. Because of this, potentially untrusted content cannot opt into
suborigins, unlike iframe sandboxes. If they could, then an XSS on a site could
enter a specific suborigin and access all of its resources, thus violating the
entire privilege separation suborigins are intended to protect. To prevent
this, the server (rather than a resource itself) is treated as the only
authoritative source of the suborigin namespace of a resource. This is
implemented through an additional header-only Content Security Policy directive
<code>suborigin</code>, which takes a string value that is the namespace. For example, to
put a resource in the <code>testing</code> suborigin namespace, the server would specify
the following directive in the CSP header:</p>

      <pre><code>suborigin: testing
</code></pre>

    </section>
    <p><!-- /Framework::Defining a Suborigin::Opting into a Suborigin --></p>

    <section>
      <h3 id="accessing-the-suborigin-in-javascript">Accessing the Suborigin in JavaScript</h3>
      <p class="issue">I don’t have a great idea for how to do this yet. Should it be as simple as
document.location.suborigin? Or should it be serialized into document.origin,
plus a deserialization mechanism? (jww)</p>

    </section>
    <p><!-- /Framework::Defining a Suborigin::Accessing the Suborigin in JavaScript --></p>

  </section>
  <p><!-- /Framework::Defining a Suborigin --></p>

  <section>
    <h3 id="access-control">Access Control</h3>

    <p>Cross-origin (including cross-suborigin) communication is tricky when suborigins
are involved because they need to be backwards compatible with user agents that
do not support suborigins while providing origin-separation for user agents that
do support suborigins. The following discussions discuss the three major
cross-origin mechanisms that are relevant.</p>

    <section>
      <h3 id="cors">CORS</h3>

      <p>For pages in a suborigin namespace, all <code>XMLHttpRequest</code>s to any URL should be
treated as cross-origin, thus triggering CORS [[!CORS]] logic with special
<code>Finer-Origin:</code> and <code>Suborigin:</code> headers added. Additionally, the <code>Origin:</code>
header that is normally applied to cross-origin requests should <em>not</em> be
added. These header changes are needed so that a server that recognizes
suborigins can see the suborigin namespace the request is coming from and apply
the appropriate CORS headers as is appropriate, while legacy servers will not
“accidentally” approve cross-origin requests because of an <code>Origin</code> header that
provides an incomplete picture of the origin (that is, an origin without the
suborigin).</p>

      <p>The <code>Finer-Origin:</code> header takes a value identical to the Origin Header, as
defined in [[!RFC6454]]. The <code>Suborigin:</code> header takes a string value that is
the suborigin namespace. The former servers identically as the <code>Origin:</code> header,
but in a purposefully backwards incompatible way, while the <code>Suborigin:</code> header
allows a server to make a more nuanced access control choice. A user agent must
not include more than one <code>Finer-Origin:</code> header and must not include more than
one <code>Suborigin:</code> field.</p>

      <p>Similar changes are needed for response from the server with the addition of
<code>Access-Control-Allow-Finer-Origin</code> and <code>Access-Control-Allow-Suborigin</code>
response headers. The former takes the same values as
<code>Access-Control-Allow-Origin</code> as defined in [[!CORS]], while the later takes a
string value that matches allowed suborigin namespaces, or <code>*</code> to allow all
suborigin namespaces.</p>

      <p class="issue">I expect that this will be a relatively controversial part of the proposal, but
I think the concern is pretty important. In particular, a lot of the potential
benefits of the proposal are eliminated if the Origin header is set with the
broad, traditional origin as an isolated but compromised suborigin could just
request private information from the other origin. That having been said, we
might be able to bypass a lot of these concerns by using the Origin header but
putting the serialized suborigin as described above it its place. This would
require monkey patching the Origin spec’s syntax of the Origin header.</p>

    </section>
    <p><!-- /Framework::Access Control::CORS --></p>

    <section>
      <h3 id="postmessage">postMessage</h3>

      <p>Cross-origin messaging via <code>postMessage</code> [[!WebMessaging]] provides many of the
same concerns as CORS. Namely, it is necessary for the recipient to see the
suborigin namespace of the message sender so an appropriate access control
decision can be made, and similarly, legacy applications should by default treat
these messages as not coming from the traditional origin of the sender.</p>

      <p>To enforce this, when a message is sent from a suborigin namespace, the receiver
has the <code>event.origin</code> value set to <code>null</code> so if it is read, it is not treated
as coming from any particular origin. Instead, new propriets of
<code>event.finerorigin</code> and <code>event.suborigin</code> should be set the scheme/host/port and
suborigin namespace, respectively.</p>

      <p class="issue">Similar to the CORS case, another option is to set <code>event.origin</code> to the
serialized namespace and then provide a deserialization tool.</p>

    </section>
    <p><!-- /Framework::Access Control::postMessage --></p>

    <section>
      <h3 id="workers">Workers</h3>
      <p class="issue">We need a story here. I basically think that workers should be treated as
if they’re in the same suborigin as whatever created them, but I’m also open to
other suggestions. Particularly tricky are service workers, which for simplicity
sake I suggest we treat as applying universally to all suborigins at a single
physical origin since it works in terms of network requests, and suborigins are
not relevant to network requests. Pull requests welcome.</p>

    </section>
    <p><!-- /Framework::Access Control::Workers --></p>

  </section>
  <p><!-- /Framework::Access Control --></p>

</section>
<p><!-- /Framework --></p>

<section>
  <h3 id="impact-on-web-platform">Impact on Web Platform</h3>

  <p>Content inside a suborigin namespace is severely restricted in what the hosted
content can do. The restrictions match the behavior of an iframe with the
sandbox attribute set to the value of <code>allow-scripts</code> [[!HTML]]. While more
specifics are described below, the general idea here is to put suborigin
namespaces in a “default secure” context. However, restrictions may be lifted
going forward at a time when a way to whitelist particular Web platform
permissions is well-defined.</p>

  <section>
    <h3 id="examples-1">Examples</h3>

  </section>
  <p><!-- /Impact on Web Platform::Examples --></p>

  <section>
    <h3 id="relationship-with-sensitive-permissions">Relationship with Sensitive Permissions</h3>

    <p>DOM storage, cookies, document.domain, etc.</p>

  </section>
  <p><!-- /Impact on Web Platform::Relationship with Sensitive Permissions --></p>

</section>
<p><!-- /Impact on Web Platform --></p>

<section>
  <h3 id="algorithms">Algorithms</h3>

  <p>Similar to comparison and serialization sections in Origin Spec:
https://tools.ietf.org/html/rfc6454</p>

</section>
<p><!-- /Algorithms --></p>

<section>
  <h3 id="security-considerations">Security Considerations</h3>

  <section>
    <h3 id="data-leakage">Data leakage</h3>

  </section>
  <p><!-- /Security Considerations::Data leakage --></p>

  <section>
    <h3 id="presentation-of-suborigins-to-users">Presentation of Suborigins to Users</h3>

  </section>
  <p><!-- /Security Considerations::Presentation of Suborigins to Users --></p>

  <section>
    <h3 id="not-overthrowing-same-origin-policy">Not Overthrowing Same-origin Policy</h3>

  </section>
  <p><!-- /Security Considerations::Not Overthrowing Same-origin Policy --></p>

</section>
<p><!-- /Security Considerations --></p>

</body>
</html>
