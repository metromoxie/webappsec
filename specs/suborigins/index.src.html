<h1>Suborigins</h1>
<pre class='metadata'>
Status: ED
ED: https://w3c.github.io/webappsec/specs/suborigins/
Shortname: suborigins
Level: 1
Editor: Joel Weinberger Google, Inc. jww@google.com
Abstract: This specification defines a mechanism by which a server may specify a web resource response a new origin in the user agent which is a combination of the server's origin and a specified namespace.
Group: webappsec
</pre>

<section>
<h2 id="intro">Introduction</h2>

<em>This section is not normative.</em>

Currently, web applications are almost always compartmentalized by using
separate host names to establish separate web origins. This is useful for
helping to prevent XSS and other cross-origin attacks, but has many unintended
consequences. For example, it causes latency due to additional DNS lookups,
removes the ability to use single-origin features (such as the
history.pushState API), and creates cryptic host name changes in the user
experience. Perhaps most importantly, it results in an extremely inflexible
architecture that, once rolled out, cannot be easily and transparently changed
later on.

There are several mechanisms for reducing the attack surface for XSS without
creating separate host-name based origins, but each pose their own problems.
Per-page Suborigins is an attempt to fill some of those gaps. Two of the most
notable mechanisms are Sandboxed Frames and Content Security Policy (CSP). Both
are powerful but have shortcomings and there are many external developers
building legacy applications that find they cannot use those tools.

Sandboxed frames can be used to completely separate untrusted content, but they
pose a large problem for containing trusted but potentially buggy code because
it is very difficult, by design, for them to communicate with other frames. The
synthetic origins assigned in a sandboxed frame are random and unpredictable,
making the use of postMessage and CORS difficult. Moreover, because they are by
definition unique origins, with no relationship to the original origin,
designing permissions for them to access resources of the original origin would
be difficult.

Content Security Policy is also promising but is generally incompatible with
current website design. Many notable companies found it impractical to retrofit
most of their applications with it. On top of this, until all applications
hosted within a single origin are simultaneously put behind CSP, the mechanism
offers limited incremental benefits, which is especially problematic for
companies with large portfolios of disparate products all under the same domain.

<h3 id="goals">Goals</h3>

<ol>
  <li>
    Provide a way for different applications hosted at the same real origin to
    separate their content into separate logical origins. For example,
    https://foobar.com/application and https://foobar.com/widget, today, are, by
    definition, in the same origin, even if they're different applications. Thus
    an XSS at https://foobar.com/application means an XSS at
    https://foobar.com/widget, even if https://foobar.com/widget is "protected"
    by a strong Content Security Policy.
  </li>

  <li>
    Similarly, provide a way for content authors to split their applications
    into logical modules with origin level separation without using different
    real origins. Content authors should not have to choose between putting all
    of their content in the same origin, on different real origins, or putting
    content in anonymous unique origins (sandboxes).
  </li>

  <li>
    Provide a way for content authors to attribute different permissions such as
    cookie access, storage access, etc. to different suborigins.
  </li>

</ol>

Issue: Not sure how to actually refer to 'real origins'. This is a terrible
name, and we need a better way to talk about them. Maybe physical origin?
Traditional origin? (jww)

</section>
